<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nuestro Universo de Amor</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Arial', sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ff69b4;
            text-shadow: 0 0 5px white;
            z-index: 100;
            display: block;
            pointer-events: none;
            font-size: 1.2em;
        }
        #message-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            max-width: 80%;
            text-align: center;
            opacity: 0;
            transition: opacity 1s;
            z-index: 100;
            border: 2px solid #ff69b4;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #music-control {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            color: white;
            z-index: 1000;
        }
        .progress-bar {
            width: 50%;
            height: 20px;
            border: 2px solid #ff69b4;
            margin-top: 20px;
        }
        .progress {
            height: 100%;
            width: 0%;
            background: #ff69b4;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h2>Cargando Nuestro Universo de Amor...</h2>
        <div class="progress-bar"><div class="progress" id="progress"></div></div>
    </div>
    
    <div id="info">Nuestro Universo de Amor ‚ù§Ô∏è</div>
    <div id="message-box"></div>
    <div id="controls">Controles: WASD para moverte, rat√≥n para mirar alrededor, Espacio para saltar</div>
    <div id="music-control">üîä M√∫sica: ON</div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/TextureLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/objects/Water.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/objects/Sky.js"></script>
    
    <script>
        // Variables globales
        let scene, camera, renderer, controls, player;
        let messageBox, currentMessage = null;
        let musicEnabled = true;
        let audioListener, sound;
        let inWeddingArea = false;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let velocity = new THREE.Vector3();
        let prevTime = performance.now();
        
        // Texturas b√°sicas
        const textures = {
            grass: null,
            tree: null,
            wood: null,
            brick: null,
            flower: null,
            water: null
        };
        
        // Mensajes rom√°nticos
        const messages = [
            { position: {x: -50, z: 30}, text: "Eres lo mejor que tengo en mi vida, gracias por darme ganas de seguir viviendola üíñ" },
            { position: {x: 80, z: -40}, text: "16 de noviembre de 2023, el d√≠a m√°s feliz de mi vida üíó" },
            { position: {x: 120, z: 20}, text: "Estoy orgulloso de ti cada d√≠a, mi ni√±a hermosa üíï" },
            { position: {x: -30, z: -60}, text: "Tu sonrisa ilumina mis d√≠as m√°s oscuros ‚ú®" },
            { position: {x: 90, z: 80}, text: "Nada me hace m√°s feliz que pasar tiempo contigo üíû" },
            { position: {x: -100, z: -90}, text: "Eres mi raz√≥n para ser mejor persona cada d√≠a üåü" },
            { position: {x: 150, z: 0}, text: "Cada momento a tu lado es un regalo del universo üí´" },
            { position: {x: -80, z: 100}, text: "Tus ojos son mi constelaci√≥n favorita ‚ú®" }
        ];
        
        const weddingMessage = "Alg√∫n d√≠a nos casaremos y formaremos una hermosa familia, haremos a Evangeline y G√©nesis reales üíó";
        
        // Inicializar el juego
        function init() {
            // Mostrar pantalla de carga
            const loadingScreen = document.getElementById('loading-screen');
            const progressBar = document.getElementById('progress');
            
            // Crear escena
            scene = new THREE.Scene();
            
            // Crear c√°mara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 50);
            
            // Crear renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Configurar elementos de la UI
            messageBox = document.getElementById('message-box');
            
            // Cargar texturas
            const textureLoader = new THREE.TextureLoader();
            const texturePromises = [];
            
            // Textura de hierba
            texturePromises.push(new Promise(resolve => {
                textures.grass = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg', resolve);
                textures.grass.wrapS = textures.grass.wrapT = THREE.RepeatWrapping;
                textures.grass.repeat.set(20, 20);
            }));
            
            // Textura de √°rbol
            texturePromises.push(new Promise(resolve => {
                textures.tree = textureLoader.load('https://threejs.org/examples/textures/crate.gif', () => {
                    textures.tree.colorSpace = THREE.SRGBColorSpace;
                    resolve();
                });
            }));
            
            // Textura de madera
            texturePromises.push(new Promise(resolve => {
                textures.wood = textureLoader.load('https://threejs.org/examples/textures/wood.jpg', () => {
                    textures.wood.colorSpace = THREE.SRGBColorSpace;
                    resolve();
                });
            }));
            
            // Textura de ladrillo
            texturePromises.push(new Promise(resolve => {
                textures.brick = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg', () => {
                    textures.brick.colorSpace = THREE.SRGBColorSpace;
                    resolve();
                });
            }));
            
            // Textura de flor
            texturePromises.push(new Promise(resolve => {
                textures.flower = new THREE.MeshStandardMaterial({ 
                    color: 0xFF69B4,
                    emissive: 0xFF69B4,
                    emissiveIntensity: 0.3
                });
                resolve();
            }));
            
            // Textura de agua
            texturePromises.push(new Promise(resolve => {
                textures.water = new THREE.TextureLoader().load('https://threejs.org/examples/textures/waternormals.jpg', texture => {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    resolve();
                });
            }));
            
            // Actualizar barra de progreso
            let loadedCount = 0;
            const totalCount = texturePromises.length;
            
            texturePromises.forEach(promise => {
                promise.then(() => {
                    loadedCount++;
                    const progress = Math.floor((loadedCount / totalCount) * 100);
                    progressBar.style.width = `${progress}%`;
                    
                    if (loadedCount === totalCount) {
                        // Todo cargado, configurar escena
                        setTimeout(() => {
                            loadingScreen.style.opacity = 0;
                            setTimeout(() => {
                                loadingScreen.style.display = 'none';
                            }, 500);
                            
                            setupScene();
                        }, 500);
                    }
                });
            }));
        }
        
        function setupScene() {
            // Configurar cielo
            const sky = new THREE.Sky();
            sky.scale.setScalar(10000);
            scene.add(sky);

            const skyUniforms = sky.material.uniforms;
            skyUniforms['turbidity'].value = 10;
            skyUniforms['rayleigh'].value = 2;
            skyUniforms['mieCoefficient'].value = 0.005;
            skyUniforms['mieDirectionalG'].value = 0.8;
            
            // Configurar sol
            const sun = new THREE.Vector3();
            const phi = THREE.MathUtils.degToRad(90 - 30);
            const theta = THREE.MathUtils.degToRad(180);
            sun.setFromSphericalCoords(1, phi, theta);
            skyUniforms['sunPosition'].value.copy(sun);
            
            // Configurar iluminaci√≥n
            setupLights(sun);
            
            // Configurar controles
            setupControls();
            
            // Configurar m√∫sica
            setupAudio();
            
            // Crear terreno y entorno
            createEnvironment();
            
            // Crear pueblo
            createVillage();
            
            // Crear lago
            createLake();
            
            // Crear √°rea de boda
            createWeddingArea();
            
            // A√±adir mensajes
            createMessageMarkers();
            
            // Configurar eventos
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('music-control').addEventListener('click', toggleMusic);
            
            // Iniciar loop de animaci√≥n
            animate();
        }
        
        function setupLights(sunPosition) {
            // Luz ambiental
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            // Luz direccional (sol)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.copy(sunPosition);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);
            
            // Luz de relleno
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-100, 50, 100);
            scene.add(fillLight);
        }
        
        function setupControls() {
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
            
            // Configurar colisi√≥n simple (para evitar caer del mundo)
            const blocker = document.createElement('div');
            blocker.style.position = 'absolute';
            blocker.style.width = '100%';
            blocker.style.height = '100%';
            blocker.style.backgroundColor = 'rgba(0,0,0,0.5)';
            blocker.style.display = 'none';
            blocker.style.justifyContent = 'center';
            blocker.style.alignItems = 'center';
            blocker.style.color = 'white';
            blocker.innerHTML = '<h2>Haz clic para jugar</h2>';
            document.body.appendChild(blocker);
            
            blocker.addEventListener('click', function() {
                controls.lock();
            });
            
            controls.addEventListener('lock', function() {
                blocker.style.display = 'none';
            });
            
            controls.addEventListener('unlock', function() {
                blocker.style.display = 'flex';
            });
            
            // Mostrar bloqueador inicial
            blocker.style.display = 'flex';
        }
        
        function setupAudio() {
            audioListener = new THREE.AudioListener();
            camera.add(audioListener);
            
            sound = new THREE.Audio(audioListener);
            const audioLoader = new THREE.AudioLoader();
            
            // Usar una canci√≥n de dominio p√∫blico como placeholder
            audioLoader.load('https://assets.codepen.io/21542/howler-push-it.mp3', function(buffer) {
                sound.setBuffer(buffer);
                sound.setLoop(true);
                sound.setVolume(0.5);
                if (musicEnabled) sound.play();
            });
        }
        
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            if (musicEnabled) {
                sound.play();
                document.getElementById('music-control').textContent = 'üîä M√∫sica: ON';
            } else {
                sound.pause();
                document.getElementById('music-control').textContent = 'üîá M√∫sica: OFF';
            }
        }
        
        function createEnvironment() {
            // Crear suelo (pradera)
            const groundGeometry = new THREE.PlaneGeometry(500, 500);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                map: textures.grass,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Crear √°rboles
            const treeGeometry = new THREE.ConeGeometry(3, 8, 8);
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2);
            const treeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                map: textures.tree
            });
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                map: textures.wood
            });
            
            for (let i = 0; i < 100; i++) {
                const treeGroup = new THREE.Group();
                
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 1;
                trunk.castShadow = true;
                treeGroup.add(trunk);
                
                const treeTop = new THREE.Mesh(treeGeometry, treeMaterial);
                treeTop.position.y = 6;
                treeTop.castShadow = true;
                treeGroup.add(treeTop);
                
                // Posicionar √°rboles aleatoriamente en √°reas de bosque
                let x, z;
                if (Math.random() > 0.5) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 100 + Math.random() * 50;
                    x = Math.cos(angle) * radius;
                    z = Math.sin(angle) * radius;
                } else {
                    x = Math.random() * 400 - 200;
                    z = Math.random() * 400 - 200;
                }
                
                treeGroup.position.set(x, 0, z);
                
                // Rotaci√≥n aleatoria para variedad
                treeGroup.rotation.y = Math.random() * Math.PI * 2;
                
                // Escala aleatoria
                const scale = 0.8 + Math.random() * 0.4;
                treeGroup.scale.set(scale, scale, scale);
                
                scene.add(treeGroup);
            }
            
            // A√±adir flores
            const flowerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            
            for (let i = 0; i < 200; i++) {
                const flower = new THREE.Mesh(flowerGeometry, textures.flower);
                flower.position.x = Math.random() * 400 - 200;
                flower.position.z = Math.random() * 400 - 200;
                flower.position.y = 0.3;
                scene.add(flower);
            }
            
            // A√±adir rocas
            const rockGeometry = new THREE.DodecahedronGeometry(0.5, 1);
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x777777 });
            
            for (let i = 0; i < 50; i++) {
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.x = Math.random() * 400 - 200;
                rock.position.z = Math.random() * 400 - 200;
                rock.position.y = 0.5;
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                rock.scale.setScalar(0.5 + Math.random() * 1.5);
                scene.add(rock);
            }
        }
        
        function createVillage() {
            // Crear casas para el pueblo
            const houseGeometry = new THREE.BoxGeometry(8, 6, 8);
            const roofGeometry = new THREE.ConeGeometry(5, 3, 4);
            roofGeometry.rotateY(Math.PI / 4);
            const houseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xF5DEB3,
                map: textures.brick
            });
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                map: textures.wood
            });
            
            // Crear varias casas en un √°rea
            for (let i = 0; i < 15; i++) {
                const houseGroup = new THREE.Group();
                
                const house = new THREE.Mesh(houseGeometry, houseMaterial);
                house.position.y = 3;
                house.castShadow = true;
                house.receiveShadow = true;
                houseGroup.add(house);
                
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = 7.5;
                roof.castShadow = true;
                houseGroup.add(roof);
                
                // Posicionar casas en un √°rea semicircular
                const angle = Math.PI * 0.6 * (i / 14) - Math.PI * 0.3;
                const radius = 40;
                houseGroup.position.x = -120 + Math.cos(angle) * radius;
                houseGroup.position.z = -80 + Math.sin(angle) * radius;
                
                // Rotar casas hacia el centro
                houseGroup.rotation.y = -angle + Math.PI;
                
                scene.add(houseGroup);
            }
            
            // Crear un camino
            const pathGeometry = new THREE.PlaneGeometry(15, 100);
            const pathMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.rotation.x = -Math.PI / 2;
            path.position.x = -120;
            path.position.z = -80;
            scene.add(path);
            
            // Crear farolas
            const lampPostGeometry = new THREE.CylinderGeometry(0.3, 0.3, 8);
            const lampGeometry = new THREE.SphereGeometry(1, 8, 8);
            const lampPostMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const lampMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFF99,
                emissive: 0xFFFF99,
                emissiveIntensity: 1
            });
            
            for (let i = 0; i < 6; i++) {
                const lampGroup = new THREE.Group();
                
                const post = new THREE.Mesh(lampPostGeometry, lampPostMaterial);
                post.position.y = 4;
                lampGroup.add(post);
                
                const lamp = new THREE.Mesh(lampGeometry, lampMaterial);
                lamp.position.y = 8;
                lampGroup.add(lamp);
                
                // Posicionar farolas a lo largo del camino
                lampGroup.position.x = -120 + (i * 20 - 50);
                lampGroup.position.z = -80;
                
                // A√±adir luz
                const light = new THREE.PointLight(0xFFFF99, 1, 10);
                light.position.set(lampGroup.position.x, 8, lampGroup.position.z);
                scene.add(light);
                
                scene.add(lampGroup);
            }
        }
        
        function createLake() {
            // Crear agua
            const waterGeometry = new THREE.PlaneGeometry(100, 100);
            
            const water = new THREE.Water(
                waterGeometry,
                {
                    textureWidth: 512,
                    textureHeight: 512,
                    waterNormals: textures.water,
                    sunDirection: new THREE.Vector3(),
                    sunColor: 0xffffff,
                    waterColor: 0x0077be,
                    distortionScale: 3.7,
                    fog: scene.fog !== undefined
                }
            );
            
            water.rotation.x = -Math.PI / 2;
            water.position.set(100, 0.1, 100);
            scene.add(water);
            
            // Crear isla en el lago
            const islandGeometry = new THREE.CylinderGeometry(15, 15, 1, 32);
            const islandMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x7CFC00,
                map: textures.grass
            });
            const island = new THREE.Mesh(islandGeometry, islandMaterial);
            island.position.set(100, 0, 100);
            scene.add(island);
            
            // A√±adir √°rbol especial en la isla
            const specialTreeGroup = new THREE.Group();
            
            const trunkGeometry = new THREE.CylinderGeometry(1, 1, 4);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            specialTreeGroup.add(trunk);
            
            const leavesGeometry = new THREE.SphereGeometry(4, 8, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0xFF69B4 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 6;
            specialTreeGroup.add(leaves);
            
            specialTreeGroup.position.set(100, 0, 100);
            scene.add(specialTreeGroup);
        }
        
        function createWeddingArea() {
            // Crear √°rea de boda (p√©rgola) en una colina
            const hillGeometry = new THREE.CylinderGeometry(20, 30, 5, 32);
            const hillMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x7CFC00,
                map: textures.grass
            });
            const hill = new THREE.Mesh(hillGeometry, hillMaterial);
            hill.position.set(-150, 2.5, 150);
            scene.add(hill);
            
            // P√©rgola
            const pergolaMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            
            // Postes
            const postGeometry = new THREE.CylinderGeometry(0.5, 0.5, 6);
            for (let i = 0; i < 4; i++) {
                const post = new THREE.Mesh(postGeometry, pergolaMaterial);
                post.position.x = -150 + (i % 2) * 10;
                post.position.z = 150 + Math.floor(i / 2) * 10;
                post.position.y = 6;
                post.castShadow = true;
                scene.add(post);
            }
            
            // Techo
            const roofGeometry = new THREE.BoxGeometry(12, 0.3, 12);
            const roof = new THREE.Mesh(roofGeometry, pergolaMaterial);
            roof.position.set(-145, 9, 155);
            roof.castShadow = true;
            scene.add(roof);
            
            // Flores alrededor
            for (let i = 0; i < 36; i++) {
                const angle = (i / 36) * Math.PI * 2;
                const radius = 15;
                const flower = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 8, 8), 
                    textures.flower
                );
                flower.position.x = -150 + Math.cos(angle) * radius;
                flower.position.z = 150 + Math.sin(angle) * radius;
                flower.position.y = 2.5 + Math.sin(angle * 3) * 0.5;
                scene.add(flower);
            }
            
            // Alfombra roja
            const carpetGeometry = new THREE.PlaneGeometry(8, 16);
            const carpetMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
            const carpet = new THREE.Mesh(carpetGeometry, carpetMaterial);
            carpet.rotation.x = -Math.PI / 2;
            carpet.position.set(-145, 2.51, 155);
            scene.add(carpet);
            
            // Bancos
            const benchGeometry = new THREE.BoxGeometry(6, 1, 1);
            const benchMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            for (let i = 0; i < 2; i++) {
                const bench = new THREE.Mesh(benchGeometry, benchMaterial);
                bench.position.set(-145 + (i * 2 - 1) * 8, 2.5, 150 + (i ? -8 : 8));
                bench.rotation.y = i ? 0 : Math.PI;
                scene.add(bench);
            }
        }
        
        function createMessageMarkers() {
            // Crear marcadores para los mensajes (corazones flotantes)
            const heartGeometry = new THREE.SphereGeometry(0.8, 8, 8);
            const heartMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF69B4,
                emissive: 0xFF69B4,
                emissiveIntensity: 0.8
            });
            
            messages.forEach((msg, index) => {
                const heart = new THREE.Mesh(heartGeometry, heartMaterial);
                heart.position.set(msg.position.x, 2, msg.position.z);
                heart.userData = { message: msg.text };
                scene.add(heart);
                
                // Animaci√≥n de flotaci√≥n
                heart.update = function() {
                    this.position.y = 2 + Math.sin(Date.now() * 0.002 + index) * 0.5;
                    this.rotation.y += 0.02;
                };
                
                // Guardar referencia para la animaci√≥n
                heart.userData.update = heart.update;
                
                // A√±adir luz
                const light = new THREE.PointLight(0xFF69B4, 1, 5);
                light.position.set(msg.position.x, 2, msg.position.z);
                scene.add(light);
            });
        }
        
        function showMessage(text) {
            messageBox.textContent = text;
            messageBox.style.opacity = 1;
            
            // Ocultar mensaje despu√©s de 7 segundos
            if (currentMessage) clearTimeout(currentMessage);
            currentMessage = setTimeout(() => {
                messageBox.style.opacity = 0;
                currentMessage = null;
            }, 7000);
        }
        
        function checkPlayerPosition() {
            if (!controls.isLocked) return;
            
            const playerPos = controls.getObject().position;
            
            // Verificar si el jugador est√° cerca de alg√∫n mensaje
            messages.forEach(msg => {
                const distance = Math.sqrt(
                    Math.pow(playerPos.x - msg.position.x, 2) +
                    Math.pow(playerPos.z - msg.position.z, 2)
                );
                
                if (distance < 5 && (!currentMessage || messageBox.textContent !== msg.text)) {
                    showMessage(msg.text);
                }
            });
            
            // Verificar si el jugador est√° en el √°rea de boda
            const weddingDistance = Math.sqrt(
                Math.pow(playerPos.x - (-145), 2) +
                Math.pow(playerPos.z - 155, 2)
            );
            
            if (weddingDistance < 15) {
                if (!inWeddingArea) {
                    showMessage(weddingMessage);
                    inWeddingArea = true;
                    
                    // Peque√±a celebraci√≥n
                    for (let i = 0; i < 20; i++) {
                        setTimeout(() => {
                            createFirework(
                                -145 + Math.random() * 20 - 10,
                                20 + Math.random() * 10,
                                155 + Math.random() * 20 - 10
                            );
                        }, i * 200);
                    }
                }
            } else {
                inWeddingArea = false;
            }
        }
        
        function createFirework(x, y, z) {
            const colors = [0xFF69B4, 0xFF1493, 0xFF00FF, 0xFFFFFF, 0xFFFF00];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const particles = 30;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const sizes = [];
            
            for (let i = 0; i < particles; i++) {
                positions.push(0, 0, 0);
                sizes.push(1);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: 0.5,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            
            const firework = new THREE.Points(geometry, material);
            firework.position.set(x, y, z);
            scene.add(firework);
            
            // Animaci√≥n de explosi√≥n
            const speed = 0.5 + Math.random() * 0.5;
            let life = 1;
            
            function animate() {
                if (life <= 0) {
                    scene.remove(firework);
                    return;
                }
                
                life -= 0.02;
                material.opacity = life;
                
                const positionAttribute = firework.geometry.attributes.position;
                
                for (let i = 0; i < particles; i++) {
                    const i3 = i * 3;
                    positionAttribute.array[i3] += positionAttribute.array[i3] * speed;
                    positionAttribute.array[i3 + 1] += positionAttribute.array[i3 + 1] * speed;
                    positionAttribute.array[i3 + 2] += positionAttribute.array[i3 + 2] * speed;
                }
                
                positionAttribute.needsUpdate = true;
                requestAnimationFrame(animate);
            }
            
            // Configurar direcciones iniciales
            const positionAttribute = firework.geometry.attributes.position;
            
            for (let i = 0; i < particles; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                positionAttribute.array[i3] = Math.sin(phi) * Math.cos(theta);
                positionAttribute.array[i3 + 1] = Math.cos(phi);
                positionAttribute.array[i3 + 2] = Math.sin(phi) * Math.sin(theta);
            }
            
            positionAttribute.needsUpdate = true;
            animate();
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': 
                    if (canJump) {
                        velocity.y += 10; 
                        canJump = false;
                    }
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Movimiento del jugador
            if (controls.isLocked) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;
                
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 15.0 * delta; // gravedad
                
                if (moveForward) velocity.z -= 20.0 * delta;
                if (moveBackward) velocity.z += 20.0 * delta;
                if (moveLeft) velocity.x -= 20.0 * delta;
                if (moveRight) velocity.x += 20.0 * delta;
                
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                // Verificar si est√° en el suelo
                if (controls.getObject().position.y < 2) {
                    velocity.y = 0;
                    controls.getObject().position.y = 2;
                    canJump = true;
                }
                
                prevTime = time;
            }
            
            // Actualizar animaciones de corazones
            scene.children.forEach(child => {
                if (child.userData && child.userData.update) {
                    child.userData.update();
                }
            });
            
            // Verificar posici√≥n del jugador
            checkPlayerPosition();
            
            // Renderizar escena
            renderer.render(scene, camera);
        }
        
        // Iniciar el juego
        init();
    </script>
</body>
</html>
