<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HÃ©lice de ADN</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/controls/OrbitControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 50);

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit controls for interaction
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;

        // Light setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(50, 50, 50);
        scene.add(pointLight);

        // Create the DNA Helix
        const helixGroup = new THREE.Group();

        const createHelix = () => {
            const radius = 4;
            const height = 40;
            const turns = 15;
            const segments = 300;
            const step = (Math.PI * 2 * turns) / segments;

            // Red and blue spheres
            const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const redMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 });
            const blueMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff, emissive: 0x000055 });

            for (let i = 0; i <= segments; i++) {
                const angle = i * step;
                const y = (i / segments) * height - height / 2;

                // Red spheres
                const redSphere = new THREE.Mesh(sphereGeometry, redMaterial);
                redSphere.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
                helixGroup.add(redSphere);

                // Blue spheres
                const blueSphere = new THREE.Mesh(sphereGeometry, blueMaterial);
                blueSphere.position.set(Math.cos(angle + Math.PI) * radius, y, Math.sin(angle + Math.PI) * radius);
                helixGroup.add(blueSphere);
            }

            // Connectors (cylinders)
            const cylinderGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
            const cylinderMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });

            for (let i = 0; i < segments; i++) {
                const angle = i * step;
                const y = (i / segments) * height - height / 2;

                const nextAngle = (i + 1) * step;
                const nextY = ((i + 1) / segments) * height - height / 2;

                const connector = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                const start = new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
                const end = new THREE.Vector3(Math.cos(angle + Math.PI) * radius, y, Math.sin(angle + Math.PI) * radius);

                connector.position.copy(start).add(end).multiplyScalar(0.5);
                connector.lookAt(end);
                connector.scale.y = start.distanceTo(end);

                helixGroup.add(connector);
            }
        };

        createHelix();
        scene.add(helixGroup);

        // Animation loop
        const animate = () => {
            requestAnimationFrame(animate);
            helixGroup.rotation.y += 0.005; // Slow rotation for better visualization
            renderer.render(scene, camera);
            controls.update();
        };

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
